<style>
    * {
        font-family: monospace;
    }
    
    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
    }

    #top-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 50px;
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        display: flex;
        align-items: center;
        padding: 0 10px;
        z-index: 100;
        width: 100%;
        overflow-x: scroll;
        overflow-y: hidden;
        scrollbar-width: none;
    }

    #actions-bar {
        position: fixed;
        top: 50px;
        left: 0;
        right: 0;
        height: 35px;
        background-color: #f8f8f8;
        border-bottom: 1px solid #ccc;
        display: flex;
        align-items: center;
        padding: 0 2.5px;
    }

    #container {
        position: absolute;
        top: 85px;
        left: 0;
        right: 0;
        bottom: 0;
        box-sizing: border-box;
        padding: 10px;
    }

    iframe {
        width: 100%;
        height: 100%;
        border: none;
    }

    .tab {
        display: inline-block;
        padding: 10px;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        margin-right: 5px;
        cursor: pointer;
        font-size: 16px;
        user-select: none;
        white-space: nowrap;
    }

    .action-tab {
        display: inline-block;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        cursor: pointer;
        font-size: 14px;
        user-select: none;
        padding: 0 5px;
        height: 25px;
        line-height: 25px;
        margin-right: 5px;
    }

    .action-tab:hover {
        background-color: #d0d0d0;
    }

    .selected {
        background-color: #d0d0d0;
        border-bottom: 2px solid #007bff;
    }

    .hidden {
        display: none;
    }

    .note {
        font-family: monospace;
        width: 100%;
        height: 100%;
        resize: none;
        outline: none;
        border: none;
    }

    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    #other-screen {
        position: fixed;
        display: flex;
        justify-content: center;
        align-items: center;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        flex-direction: column;
    }

    .other-button {
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        cursor: pointer;
        padding: 2px;
        margin-top: 2px;
        user-select: none;
        text-align: center;
        width: 100%;
    }

    .button-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 200px;
        gap: 2px;
    }

    .other-button:hover {
        background-color: #d0d0d0;
    }
</style>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.5.3/math.js"></script>
</head>
<body>
    <div id="loading-screen" style="display: none;">
        <h1>Loading...</h1>
    </div>
    <div id="other-screen" style="display: none;">
        <div class="button-container">
            <div style="user-select: none;">Other Options:</div>
            <div class="other-button" id="other-clear-saved" onclick="clearSavedTabs()">Clear Saved Tabs</div>
            <div class="other-button" id="clear-all-tabs" onclick="clearAllTabs()">Reset All Tabs</div>
            <div class="other-button" id="other-close" onclick="document.getElementById('other-screen').style.display = 'none'">Close</div>
        </div>
    </div>
    <div id="top-bar">
    </div>
    <div id="actions-bar">
        <div class="action-tab" id="new">New <u>Tab</u></div>
        <div class="action-tab" id="delete"><u>Del</u>ete Current Tab</div>
        <div class="action-tab" id="export"><u>E</u>xport Tabs</div>
        <div class="action-tab" id="import"><u>I</u>mport Tabs</div>
        <div class="action-tab" id="docs" onclick="openDocs()">Documentation</div>
        <div class="action-tab" id="other" onclick="openOtherOptions()">Other</div>
    </div>
    <div id="container"></div>
</body>
 
<script>
    const { shell, ipcRenderer } = require('electron');
    const fs = require('fs');
    

    let topBar = document.getElementById('top-bar');
    let container = document.getElementById('container');

    let deleteButton = document.getElementById('delete');
    let exportButton = document.getElementById('export');
    let importButton = document.getElementById('import');
    let newTabButton = document.getElementById('new');
    let docsButton = document.getElementById('docs');
    let otherButton = document.getElementById('other');

    let otherClearSaved = document.getElementById('other-clear-saved');
    let otherClose = document.getElementById('other-close');

    const loadingScreen = document.getElementById('loading-screen');
    const otherScreen = document.getElementById('other-screen');

    let tabCounter = 0;

    function openDocs() {
        shell.openExternal('https://rus1130.github.io/projects/mdparser.html?url=https://rus1130.github.io/calculator/README.md');
    }

    function openOtherOptions() {
        otherScreen.style.display = 'flex';
    }

    function clearSavedTabs() {
        localStorage.removeItem('tabs');
    }

    topBar.addEventListener('wheel', function (e) {
        if (e.deltaY !== 0) {
            this.scrollLeft += e.deltaY > 0 ? 12.5 : -12.5;
            e.preventDefault(); // prevent vertical scroll
        }
    });

    function clearAllTabs() {
        let tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            document.querySelector(`#calcpad-${tab.getAttribute('data-tab')}`).remove();
            tab.remove();
        });
        tabCounter = 0;
        createTabAndCalcpad();
        otherScreen.style.display = 'none';
    }

    ipcRenderer.on('app-before-quit', (event, message) => {
        localStorage.setItem('tabs', JSON.stringify(getTabsAsJson()));
    });

    function restoreCaretOffset(pad, offset) {
        const sel = window.getSelection();
        const textLength = pad.textContent.length;
        const safeOffset = Math.min(offset, textLength);

        const textNode = pad.firstChild;
        if (textNode) {
            sel.removeAllRanges();
            const range = document.createRange();
            range.setStart(textNode, safeOffset);
            range.collapse(true);
            sel.addRange(range);
        }
    }

    function getCaretCharacterOffsetWithin(element) {
        const selection = window.getSelection();
        let charCount = -1;

        if (selection.anchorNode && element.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            const preRange = range.cloneRange();
            preRange.selectNodeContents(element);
            preRange.setEnd(range.endContainer, range.endOffset);
            charCount = preRange.toString().length;
        }

        return charCount;
    }

    function getTabsAsJson(){
        let tabs = Array.from(document.querySelectorAll('.tab'));

        let exportData = tabs.map(tab => {

            let calcpadElement = document.getElementById(`calcpad-${tab.getAttribute('data-tab')}`); 

            let calcpadContent = calcpadElement.textContent;

            return {
                name: tab.textContent,
                content: calcpadContent
            };
        });

        return exportData;
    }

    if(localStorage.getItem('tabs')){
        let tabData = JSON.parse(localStorage.getItem('tabs'));
        loadingScreen.style.display = 'flex';
        setTabsWithJson(tabData);
    }

    function setTabsWithJson(data){
        let tabs = document.querySelectorAll('.tab');

        // delete all tabs
        tabs.forEach(tab => {
            document.querySelector(`#calcpad-${tab.getAttribute('data-tab')}`).remove();
            tab.remove()
        });

        tabCounter = 0;

        data.forEach(() => {
            createTabAndCalcpad()
        })

        let newTabs = document.querySelectorAll('.tab');
        newTabs.forEach((tab, index) => {
            tab.textContent = data[index].name;
            tab.setAttribute('data-tab', index + 1);


            let calcpadElement = document.getElementById(`calcpad-${index + 1}`);

            if (index === 0) {
                tab.classList.add('selected');
                calcpadElement.classList.remove('hidden');
            } else {
                calcpadElement.classList.add('hidden');
            }
        });

        newTabs.forEach((tab, index) => {
            tab.textContent = data[index].name;
            tab.setAttribute('data-tab', index + 1);

            let calcpadElement = document.getElementById(`calcpad-${index + 1}`);

            if (index === 0) {
                tab.classList.add('selected');
                calcpadElement.classList.remove('hidden');
            } else {
                calcpadElement.classList.add('hidden');
            }
        });

        setTimeout(() => {
            newTabs.forEach((tab, index) => {
                let calcpadElement = document.getElementById(`calcpad-${index + 1}`);
                
                calcpadElement.textContent = data[index].content;
            })
            loadingScreen.style.display = 'none';
        }, 50 * newTabs.length);

        newTabs[0].click()
    }

    function setCaretPosition(element, offset) {
        let node = element.firstChild;
        let charsLeft = offset;

        // Walk through the node tree to find the right spot
        function findNode(node) {
            while (node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    if (charsLeft <= node.textContent.length) {
                        return { node, offset: charsLeft };
                    } else {
                        charsLeft -= node.textContent.length;
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const result = findNode(node.firstChild);
                    if (result) return result;
                }
                node = node.nextSibling;
            }
            return null;
        }

        const result = findNode(node);
        if (result) {
            const range = document.createRange();
            const sel = window.getSelection();
            range.setStart(result.node, result.offset);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }

    function keybindCondition(key, meta = { shiftKey: false, ctrlKey: false, altKey: false }, e){
        meta.shiftKey = meta.shiftKey || false;
        meta.ctrlKey = meta.ctrlKey || false;
        meta.altKey = meta.altKey || false;

        return e.key == key && e.shiftKey == meta.shiftKey && e.ctrlKey == meta.ctrlKey && e.altKey == meta.altKey;
    }

    function getLines(pad){
        let selection = window.getSelection();
        let start = selection.anchorOffset;
        let lines = pad.textContent.substring(0, start).split(/\n/);

        return lines;
    }

    function getCurrentLine(pad){
        let selection = window.getSelection();
        let start = selection.anchorOffset;
        let lines = getLines(pad);

        let lineIndex = 0;
        let lineLength = 0;
        for (let i = 0; i < lines.length; i++) {
            lineLength += lines[i].length + 1; // +1 for the newline character
            if (lineLength > start) {
                lineIndex = i;
                break;
            }
        }
        
        let line = lines[lineIndex];
        return line
    }

    document.addEventListener('keydown', (e) => {
        if (keybindCondition("e", { ctrlKey: true }, e)) {
            e.preventDefault();
            exportButton.click();
        }
        if (keybindCondition("i", { ctrlKey: true }, e)) {
            e.preventDefault();
            importButton.click();
        }
        if (keybindCondition("Tab", { ctrlKey: true }, e)) {
            e.preventDefault();
            newTabButton.click();
        }
        if (keybindCondition("Delete", { ctrlKey: true }, e)) {
            e.preventDefault();
            deleteButton.click();
        }

        // ctrl + left arrow and ctrl + right arrow to switch tabs
        if (keybindCondition("ArrowLeft", { ctrlKey: true }, e)) {
            e.preventDefault();
            let tabs = document.querySelectorAll('.tab');
            let selectedTab = document.querySelector('.tab.selected');

            if (selectedTab.previousElementSibling) {
                selectedTab.previousElementSibling.click();
            } else {
                tabs[tabs.length - 1].click(); // Go to the last tab if there is no previous tab
            }
        } else if (keybindCondition("ArrowRight", { ctrlKey: true }, e)) {
            e.preventDefault();
            let tabs = document.querySelectorAll('.tab');
            let selectedTab = document.querySelector('.tab.selected');

            if (selectedTab.nextElementSibling) {
                selectedTab.nextElementSibling.click();
            } else {
                tabs[0].click(); // Go to the first tab if there is no next tab
            }
        }
    });

    function createCalcpad(){
        let pad = document.createElement('div');
        pad.contentEditable = "plaintext-only";
        pad.spellcheck = false;
        pad.textContent = `\n\n\n\n\n\n\n\n\n\n[symbols]\n\n`

        pad.classList.add('note');

        let scope = {};

        let contentStack = [pad.textContent];
        let caretStack = [getCaretCharacterOffsetWithin(pad)];

        let lastCaretPositionForSymbols = 0;

        let inSymbols = false;

        document.addEventListener("selectionchange", (e) => {
            let symbolsPosition = pad.textContent.lastIndexOf("[symbols]");
            let caretPosition = getCaretCharacterOffsetWithin(pad);

            if(symbolsPosition == -1){
                inSymbols = false;
                return;
            }

            if(caretPosition > (symbolsPosition + 9)){
                inSymbols = true;
            } else {
                inSymbols = false;
            }

            if(inSymbols == false){
                lastCaretPositionForSymbols = caretPosition
            }
        });

        pad.addEventListener('keydown', function(e){
            if(keybindCondition("s", {ctrlKey: true}, e)){
                e.preventDefault();
                let symbolsPosition = pad.textContent.lastIndexOf("[symbols]");

                if(symbolsPosition == -1) return;

                if(!inSymbols){
                    let lines = pad.textContent.split("\n");

                    let newCaretPosition = 0;
                    for(let i = 0; i < lines.length; i++){
                        if(i < lines.length - 1) {
                            newCaretPosition += lines[i].length + 1; // +1 for the newline character
                        } else {
                            newCaretPosition += lines[i].length; // no newline character for the last line
                        }
                    }

                    setCaretPosition(pad, newCaretPosition);
                } else {
                    setCaretPosition(pad, lastCaretPositionForSymbols);
                }
            }
            if(keybindCondition("z", {ctrlKey: true}, e)){
                e.preventDefault();
                
                contentStack.pop();
                caretStack.pop();

                let lastContent = contentStack[contentStack.length - 1];
                let lastCaretOffset = caretStack[caretStack.length - 1];

                if(lastContent != undefined){
                    pad.textContent = lastContent;
                    setCaretPosition(pad, lastCaretOffset);
                }
            }

            contentStack.push(pad.textContent);
            caretStack.push(getCaretCharacterOffsetWithin(pad));

            contentStack = [...new Set(contentStack)];
            caretStack = [...new Set(caretStack)];
        })

        pad.addEventListener('keyup', function(e){
            if(keybindCondition("z", {ctrlKey: true}, e)){
                e.preventDefault();
            }
        })

        pad.addEventListener('keydown', function(e) {
            if(keybindCondition("Tab", {shiftKey: false}, e)) {
                // symbol getting
                scope = pad.textContent.match(/\[symbols\](.*)$/s)[1].trim().split("\n").reduce((acc, line) => {
                    let [key, value] = line.split('=').map(s => s.trim());
                    if (key && value) {
                        acc[key] = parseFloat(value);
                    }
                    return acc;
                }, {});

                // actual calculation
                e.preventDefault();
                let selection = window.getSelection();
                let start = selection.anchorOffset;

                let line = getCurrentLine(pad);

                let lastArrow = line.lastIndexOf(" => ");
                let lastSemi = line.lastIndexOf(";");

                let chainer = Math.max(lastArrow, lastSemi);

                if(chainer != -1){
                    line = line.substring(chainer + (lastArrow != -1 ? 4 : 1)).trim();
                }

                let result = null;

                try {
                    result = math.evaluate(line, scope);
                } catch (e) {
                    result = "ERR! " + e.message;
                }

                if(result != undefined){
                    pad.textContent = pad.textContent.substring(0, start) + " => " + result + pad.textContent.substring(start);

                    selection.collapse(pad.firstChild, start + 4 + result.toString().length);
                }
            } else if(keybindCondition("Tab", {shiftKey: true}, e)) {
                // highlight the whole current line
                e.preventDefault();
                let selection = window.getSelection();
                let start = selection.anchorOffset;

                let line = getCurrentLine(pad);

                let newlineIndex = pad.textContent.lastIndexOf("\n", start - 1);
                let semicolonIndex = pad.textContent.lastIndexOf(";", start - 1);

                let lineStart = Math.max(newlineIndex, semicolonIndex) + 1;
                let lineEnd = pad.textContent.indexOf("\n", start); // find the end of the line

                if (lineEnd === -1) {
                    lineEnd = pad.textContent.length; // if no newline found, set end to the end of the text
                }

                selection.removeAllRanges();
                let range = document.createRange();
                range.setStart(pad.firstChild, lineStart);
                range.setEnd(pad.firstChild, lineEnd);
                selection.addRange(range);

            } else if(keybindCondition("Tab", {shiftKey: true, ctrlKey: true}, e)) {
                // highlight the whole current line, regardless of semicolons
                e.preventDefault();
                let selection = window.getSelection();
                let start = selection.anchorOffset;

                let line = getCurrentLine(pad);

                let lineStart = pad.textContent.lastIndexOf("\n", start - 1) + 1;
                let lineEnd = pad.textContent.indexOf("\n", start); // find the end of the line

                if (lineEnd === -1) {
                    lineEnd = pad.textContent.length; // if no newline found, set end to the end of the text
                }

                selection.removeAllRanges();
                let range = document.createRange();
                range.setStart(pad.firstChild, lineStart);
                range.setEnd(pad.firstChild, lineEnd);
                selection.addRange(range);
            }
        });

        return pad;
    }

    function createTabAndCalcpad(){
        tabCounter++;

        let newTab = document.createElement('div');
        newTab.classList.add('tab');
        newTab.textContent = `Tab ${tabCounter}`;
        newTab.setAttribute('data-tab', tabCounter);

        let calcpad = createCalcpad();
        calcpad.id = `calcpad-${tabCounter}`;
        calcpad.classList.add('hidden');

        let tabs = document.querySelectorAll('.tab');
        tabs.forEach(t => t.classList.remove('selected'));
        newTab.classList.add('selected');

        newTab.addEventListener('click', () => {
            let tabs = document.querySelectorAll('.tab');

            tabs.forEach(t => {
                document.getElementById(`calcpad-${t.getAttribute('data-tab')}`).style.display = 'none';
            });

            let calcpad = document.getElementById(`calcpad-${newTab.getAttribute('data-tab')}`);

            calcpad.style.display = 'block';

            calcpad.focus()

            tabs.forEach(t => t.classList.remove('selected'));
            newTab.classList.add('selected');
        });

        newTab.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            newTab.contentEditable = "plaintext-only";
            newTab.spellcheck = false;
            newTab.style.outline = "1px solid #007bff";
            newTab.focus();
            // highlight the name with range
            let range = document.createRange();
            let selection = window.getSelection();
            range.selectNodeContents(newTab);
            selection.removeAllRanges();
            selection.addRange(range);

        });

        newTab.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                newTab.contentEditable = "false";
                newTab.style.outline = "none";
                calcpad.focus()
            }
        });

        // find the active tab if there is one, otherwise append
        let activeTab = document.querySelector('.tab.selected');
        if (activeTab) {
            activeTab.insertAdjacentElement('afterend', newTab);
        } else {
            topBar.appendChild(newTab);
        }
        container.appendChild(calcpad);
        newTab.click();
    }

    newTabButton.addEventListener('click', () => {
        let tabs = document.querySelectorAll('.tab');
        createTabAndCalcpad();
    });

    deleteButton.addEventListener('click', () => {
        let tabs = document.querySelectorAll('.tab');

        if(tabs.length > 1) {
            let selectedTab = document.querySelector('.tab.selected');
            let selectedCalcpad = document.querySelector(`#calcpad-${selectedTab.getAttribute('data-tab')}`);

            // get the tab to the right
            let nextTab = selectedTab.nextElementSibling || selectedTab.previousElementSibling;
            nextTab.click()

            selectedTab.remove();
            selectedCalcpad.remove();
        }
    });

    exportButton.addEventListener('click', () => {

        let exportData = getTabsAsJson();

        let fileContent = JSON.stringify(exportData, null, 4);
        let blob = new Blob([fileContent], { type: "application/json" });
        let url = URL.createObjectURL(blob);

        let a = document.createElement("a");
        a.href = url;
        a.download = "tabs.json";
        a.click();

        URL.revokeObjectURL(url); 
    });

    importButton.addEventListener('click', () => {
        let fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';

        fileInput.addEventListener('change', (event) => {
            let file = event.target.files[0];
            if (file) {
                let reader = new FileReader();
                reader.onload = function(e) {
                    loadingScreen.style.display = 'flex';
                    tabCounter = 0;
                    
                    // artifical delay
                    let data = JSON.parse(e.target.result);
                    setTabsWithJson(data);
                    
                };
                reader.readAsText(file);
            }
        });

        fileInput.click();
    });

    if(!localStorage.getItem('tabs')) createTabAndCalcpad(); // Create the first tab and notepad on load
</script>